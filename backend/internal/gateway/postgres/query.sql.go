// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package postgres

import (
	"context"
	"time"
)

const addGroupMember = `-- name: AddGroupMember :exec
INSERT INTO group_members (group_id, user_id, created_at)
VALUES ($1, $2, current_timestamp)
`

type AddGroupMemberParams struct {
	GroupID string
	UserID  string
}

func (q *Queries) AddGroupMember(ctx context.Context, arg AddGroupMemberParams) error {
	_, err := q.db.Exec(ctx, addGroupMember, arg.GroupID, arg.UserID)
	return err
}

const createEvent = `-- name: CreateEvent :exec
INSERT INTO events (id, group_id, name, amount, event_date, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateEventParams struct {
	ID        string
	GroupID   string
	Name      string
	Amount    int32
	EventDate time.Time
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) error {
	_, err := q.db.Exec(ctx, createEvent,
		arg.ID,
		arg.GroupID,
		arg.Name,
		arg.Amount,
		arg.EventDate,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createEventPayment = `-- name: CreateEventPayment :exec
INSERT INTO event_payments (event_id, payment_id)
VALUES ($1, $2)
`

type CreateEventPaymentParams struct {
	EventID   string
	PaymentID string
}

func (q *Queries) CreateEventPayment(ctx context.Context, arg CreateEventPaymentParams) error {
	_, err := q.db.Exec(ctx, createEventPayment, arg.EventID, arg.PaymentID)
	return err
}

const createGroup = `-- name: CreateGroup :exec
INSERT INTO groups (id, name, created_by, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5)
`

type CreateGroupParams struct {
	ID        string
	Name      string
	CreatedBy string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) error {
	_, err := q.db.Exec(ctx, createGroup,
		arg.ID,
		arg.Name,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createPayment = `-- name: CreatePayment :exec
INSERT INTO payments (id, payer_id, debtor_id, amount, created_at, updated_at)
VALUES ($1, $2, $3, $4, current_timestamp, current_timestamp)
`

type CreatePaymentParams struct {
	ID       string
	PayerID  string
	DebtorID string
	Amount   int32
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) error {
	_, err := q.db.Exec(ctx, createPayment,
		arg.ID,
		arg.PayerID,
		arg.DebtorID,
		arg.Amount,
	)
	return err
}

const createRepayment = `-- name: CreateRepayment :exec
INSERT INTO payments (id, payer_id, debtor_id, amount, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateRepaymentParams struct {
	ID        string
	PayerID   string
	DebtorID  string
	Amount    int32
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateRepayment(ctx context.Context, arg CreateRepaymentParams) error {
	_, err := q.db.Exec(ctx, createRepayment,
		arg.ID,
		arg.PayerID,
		arg.DebtorID,
		arg.Amount,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (id, name, avatar, email, created_at, updated_at)
VALUES ($1, $2, $3, $4, current_timestamp, current_timestamp)
`

type CreateUserParams struct {
	ID     string
	Name   string
	Avatar string
	Email  string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.ID,
		arg.Name,
		arg.Avatar,
		arg.Email,
	)
	return err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteEvent, id)
	return err
}

const deleteEventPayment = `-- name: DeleteEventPayment :exec
DELETE FROM event_payments WHERE event_id = $1 AND payment_id = $2
`

type DeleteEventPaymentParams struct {
	EventID   string
	PaymentID string
}

func (q *Queries) DeleteEventPayment(ctx context.Context, arg DeleteEventPaymentParams) error {
	_, err := q.db.Exec(ctx, deleteEventPayment, arg.EventID, arg.PaymentID)
	return err
}

const deleteGroup = `-- name: DeleteGroup :exec
DELETE FROM groups
WHERE id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteGroup, id)
	return err
}

const deleteGroupMember = `-- name: DeleteGroupMember :exec
DELETE FROM group_members
WHERE group_id = $1 AND user_id = $2
`

type DeleteGroupMemberParams struct {
	GroupID string
	UserID  string
}

func (q *Queries) DeleteGroupMember(ctx context.Context, arg DeleteGroupMemberParams) error {
	_, err := q.db.Exec(ctx, deleteGroupMember, arg.GroupID, arg.UserID)
	return err
}

const deletePayment = `-- name: DeletePayment :exec
DELETE FROM payments WHERE id = $1
`

func (q *Queries) DeletePayment(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deletePayment, id)
	return err
}

const deletePaymentsByGroupID = `-- name: DeletePaymentsByGroupID :exec
DELETE FROM payments
WHERE id IN (
  SELECT ep.payment_id
  FROM event_payments ep
  INNER JOIN events e ON ep.event_id = e.id
  WHERE e.group_id = $1
)
`

func (q *Queries) DeletePaymentsByGroupID(ctx context.Context, groupID string) error {
	_, err := q.db.Exec(ctx, deletePaymentsByGroupID, groupID)
	return err
}

const deletePaymentsByGroupIDAndUserID = `-- name: DeletePaymentsByGroupIDAndUserID :exec
DELETE FROM payments
WHERE id IN (
  SELECT ep.payment_id
  FROM event_payments ep
  INNER JOIN events e ON ep.event_id = e.id
  INNER JOIN payments p ON ep.payment_id = p.id
  WHERE e.group_id = $1
    AND (p.payer_id = $2 OR p.debtor_id = $2)
)
`

type DeletePaymentsByGroupIDAndUserIDParams struct {
	GroupID string
	PayerID string
}

func (q *Queries) DeletePaymentsByGroupIDAndUserID(ctx context.Context, arg DeletePaymentsByGroupIDAndUserIDParams) error {
	_, err := q.db.Exec(ctx, deletePaymentsByGroupIDAndUserID, arg.GroupID, arg.PayerID)
	return err
}

const deleteRepayment = `-- name: DeleteRepayment :exec
DELETE FROM payments WHERE id = $1
`

func (q *Queries) DeleteRepayment(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteRepayment, id)
	return err
}

const findAllEvents = `-- name: FindAllEvents :many
SELECT id, group_id, name, amount, event_date, created_at, updated_at FROM events
`

func (q *Queries) FindAllEvents(ctx context.Context) ([]Event, error) {
	rows, err := q.db.Query(ctx, findAllEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Name,
			&i.Amount,
			&i.EventDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllUsers = `-- name: FindAllUsers :many
SELECT id, name, avatar, email, created_at, updated_at FROM users
`

func (q *Queries) FindAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, findAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Avatar,
			&i.Email,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findDebtorsByEventIDs = `-- name: FindDebtorsByEventIDs :many
SELECT ep.event_id, u.id, u.name, u.avatar, u.email, p.amount
FROM payments p
INNER JOIN event_payments ep ON p.id = ep.payment_id
INNER JOIN users u ON p.debtor_id = u.id
WHERE ep.event_id = ANY($1::text[])
`

type FindDebtorsByEventIDsRow struct {
	EventID string
	ID      string
	Name    string
	Avatar  string
	Email   string
	Amount  int32
}

func (q *Queries) FindDebtorsByEventIDs(ctx context.Context, eventIds []string) ([]FindDebtorsByEventIDsRow, error) {
	rows, err := q.db.Query(ctx, findDebtorsByEventIDs, eventIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindDebtorsByEventIDsRow
	for rows.Next() {
		var i FindDebtorsByEventIDsRow
		if err := rows.Scan(
			&i.EventID,
			&i.ID,
			&i.Name,
			&i.Avatar,
			&i.Email,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findEventByGroupIDAndDebtorIDAndEventID = `-- name: FindEventByGroupIDAndDebtorIDAndEventID :one
SELECT
  e.id AS event_id,
  e.group_id,
  e.name,
  e.event_date,
  p.amount,
  e.created_at,
  e.updated_at
FROM events e
INNER JOIN event_payments ep ON e.id = ep.event_id
INNER JOIN payments p ON ep.payment_id = p.id
WHERE e.group_id = $1 AND p.debtor_id = $2 AND e.id = $3
LIMIT 1
`

type FindEventByGroupIDAndDebtorIDAndEventIDParams struct {
	GroupID  string
	DebtorID string
	ID       string
}

type FindEventByGroupIDAndDebtorIDAndEventIDRow struct {
	EventID   string
	GroupID   string
	Name      string
	EventDate time.Time
	Amount    int32
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) FindEventByGroupIDAndDebtorIDAndEventID(ctx context.Context, arg FindEventByGroupIDAndDebtorIDAndEventIDParams) (FindEventByGroupIDAndDebtorIDAndEventIDRow, error) {
	row := q.db.QueryRow(ctx, findEventByGroupIDAndDebtorIDAndEventID, arg.GroupID, arg.DebtorID, arg.ID)
	var i FindEventByGroupIDAndDebtorIDAndEventIDRow
	err := row.Scan(
		&i.EventID,
		&i.GroupID,
		&i.Name,
		&i.EventDate,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findEventById = `-- name: FindEventById :one
SELECT id, group_id, name, amount, event_date, created_at, updated_at
FROM events WHERE id = $1 LIMIT 1
`

func (q *Queries) FindEventById(ctx context.Context, id string) (Event, error) {
	row := q.db.QueryRow(ctx, findEventById, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.Amount,
		&i.EventDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findEventsByGroupIDAndDebtorID = `-- name: FindEventsByGroupIDAndDebtorID :many
SELECT
  e.id AS event_id,
  e.group_id,
  e.name,
  e.event_date,
  p.amount,
  e.created_at,
  e.updated_at
FROM events e
INNER JOIN event_payments ep ON e.id = ep.event_id
INNER JOIN payments p ON ep.payment_id = p.id
WHERE e.group_id = $1 AND p.debtor_id = $2
`

type FindEventsByGroupIDAndDebtorIDParams struct {
	GroupID  string
	DebtorID string
}

type FindEventsByGroupIDAndDebtorIDRow struct {
	EventID   string
	GroupID   string
	Name      string
	EventDate time.Time
	Amount    int32
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) FindEventsByGroupIDAndDebtorID(ctx context.Context, arg FindEventsByGroupIDAndDebtorIDParams) ([]FindEventsByGroupIDAndDebtorIDRow, error) {
	rows, err := q.db.Query(ctx, findEventsByGroupIDAndDebtorID, arg.GroupID, arg.DebtorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindEventsByGroupIDAndDebtorIDRow
	for rows.Next() {
		var i FindEventsByGroupIDAndDebtorIDRow
		if err := rows.Scan(
			&i.EventID,
			&i.GroupID,
			&i.Name,
			&i.EventDate,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findGroupByID = `-- name: FindGroupByID :one
SELECT id, name, created_by, created_at, updated_at
FROM groups WHERE id = $1 LIMIT 1
`

func (q *Queries) FindGroupByID(ctx context.Context, id string) (Group, error) {
	row := q.db.QueryRow(ctx, findGroupByID, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findGroupMemberUsersByGroupID = `-- name: FindGroupMemberUsersByGroupID :many
SELECT u.id, u.name, u.avatar, u.email
FROM users u
INNER JOIN group_members gm ON u.id = gm.user_id
WHERE gm.group_id = $1
ORDER BY gm.created_at ASC
`

type FindGroupMemberUsersByGroupIDRow struct {
	ID     string
	Name   string
	Avatar string
	Email  string
}

func (q *Queries) FindGroupMemberUsersByGroupID(ctx context.Context, groupID string) ([]FindGroupMemberUsersByGroupIDRow, error) {
	rows, err := q.db.Query(ctx, findGroupMemberUsersByGroupID, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindGroupMemberUsersByGroupIDRow
	for rows.Next() {
		var i FindGroupMemberUsersByGroupIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Avatar,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findGroupMembersByGroupID = `-- name: FindGroupMembersByGroupID :many
SELECT user_id FROM group_members
WHERE group_id = $1 ORDER BY created_at ASC
`

func (q *Queries) FindGroupMembersByGroupID(ctx context.Context, groupID string) ([]string, error) {
	rows, err := q.db.Query(ctx, findGroupMembersByGroupID, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findGroupsByMemberUserID = `-- name: FindGroupsByMemberUserID :many
SELECT g.id, g.name, g.created_by, g.created_at, g.updated_at
FROM groups g
INNER JOIN group_members gm ON g.id = gm.group_id
WHERE gm.user_id = $1
ORDER BY g.created_at DESC
`

func (q *Queries) FindGroupsByMemberUserID(ctx context.Context, userID string) ([]Group, error) {
	rows, err := q.db.Query(ctx, findGroupsByMemberUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLendingsByGroupIDAndUserIDWithCursor = `-- name: FindLendingsByGroupIDAndUserIDWithCursor :many
SELECT DISTINCT e.id, e.group_id, e.name, e.amount, e.event_date, e.created_at, e.updated_at
FROM events e
INNER JOIN event_payments ep ON e.id = ep.event_id
INNER JOIN payments p ON ep.payment_id = p.id
WHERE e.group_id = $1
  AND p.payer_id = $2
  AND ($3::text IS NULL OR e.id < $3)
ORDER BY e.id DESC
LIMIT $4
`

type FindLendingsByGroupIDAndUserIDWithCursorParams struct {
	GroupID string
	PayerID string
	Cursor  *string
	Limit   int32
}

func (q *Queries) FindLendingsByGroupIDAndUserIDWithCursor(ctx context.Context, arg FindLendingsByGroupIDAndUserIDWithCursorParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, findLendingsByGroupIDAndUserIDWithCursor,
		arg.GroupID,
		arg.PayerID,
		arg.Cursor,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Name,
			&i.Amount,
			&i.EventDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaymentByDebtorId = `-- name: FindPaymentByDebtorId :one
SELECT p.id, p.payer_id, p.debtor_id, p.amount, p.created_at, p.updated_at
FROM payments p
INNER JOIN event_payments ep ON p.id = ep.payment_id
WHERE ep.event_id = $1 AND p.debtor_id = $2 LIMIT 1
`

type FindPaymentByDebtorIdParams struct {
	EventID  string
	DebtorID string
}

func (q *Queries) FindPaymentByDebtorId(ctx context.Context, arg FindPaymentByDebtorIdParams) (Payment, error) {
	row := q.db.QueryRow(ctx, findPaymentByDebtorId, arg.EventID, arg.DebtorID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PayerID,
		&i.DebtorID,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findPaymentsByEventId = `-- name: FindPaymentsByEventId :many
SELECT p.id, p.payer_id, p.debtor_id, p.amount, p.created_at, p.updated_at
FROM payments p
INNER JOIN event_payments ep ON p.id = ep.payment_id
WHERE ep.event_id = $1
`

func (q *Queries) FindPaymentsByEventId(ctx context.Context, eventID string) ([]Payment, error) {
	rows, err := q.db.Query(ctx, findPaymentsByEventId, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PayerID,
			&i.DebtorID,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRepaymentByID = `-- name: FindRepaymentByID :one
SELECT p.id, p.payer_id, p.debtor_id, p.amount, p.created_at, p.updated_at
FROM payments p
LEFT JOIN event_payments ep ON p.id = ep.payment_id
WHERE p.id = $1 AND ep.event_id IS NULL
LIMIT 1
`

func (q *Queries) FindRepaymentByID(ctx context.Context, id string) (Payment, error) {
	row := q.db.QueryRow(ctx, findRepaymentByID, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PayerID,
		&i.DebtorID,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findRepaymentsByPayerID = `-- name: FindRepaymentsByPayerID :many
SELECT p.id, p.payer_id, p.debtor_id, p.amount, p.created_at, p.updated_at
FROM payments p
LEFT JOIN event_payments ep ON p.id = ep.payment_id
WHERE p.payer_id = $1 AND ep.event_id IS NULL
ORDER BY p.created_at DESC
`

func (q *Queries) FindRepaymentsByPayerID(ctx context.Context, payerID string) ([]Payment, error) {
	rows, err := q.db.Query(ctx, findRepaymentsByPayerID, payerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PayerID,
			&i.DebtorID,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRepaymentsByPayerIDWithCursor = `-- name: FindRepaymentsByPayerIDWithCursor :many
SELECT p.id, p.payer_id, p.debtor_id, p.amount, p.created_at, p.updated_at
FROM payments p
LEFT JOIN event_payments ep ON p.id = ep.payment_id
WHERE p.payer_id = $1
  AND ep.event_id IS NULL
  AND ($2::text IS NULL OR p.id < $2)
ORDER BY p.id DESC
LIMIT $3
`

type FindRepaymentsByPayerIDWithCursorParams struct {
	PayerID string
	Cursor  *string
	Limit   int32
}

func (q *Queries) FindRepaymentsByPayerIDWithCursor(ctx context.Context, arg FindRepaymentsByPayerIDWithCursorParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, findRepaymentsByPayerIDWithCursor, arg.PayerID, arg.Cursor, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PayerID,
			&i.DebtorID,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserByID = `-- name: FindUserByID :one
SELECT id, name, avatar, email, created_at, updated_at FROM users WHERE id = $1 LIMIT 1
`

func (q *Queries) FindUserByID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Avatar,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findUsersBySearch = `-- name: FindUsersBySearch :many
SELECT id, name, avatar, email, created_at, updated_at
FROM users
WHERE ($1::text IS NOT NULL AND name ILIKE '%' || $1 || '%')
   OR ($2::text IS NOT NULL AND email ILIKE '%' || $2 || '%')
ORDER BY name ASC
LIMIT $3
`

type FindUsersBySearchParams struct {
	Name  *string
	Email *string
	Limit int32
}

func (q *Queries) FindUsersBySearch(ctx context.Context, arg FindUsersBySearchParams) ([]User, error) {
	rows, err := q.db.Query(ctx, findUsersBySearch, arg.Name, arg.Email, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Avatar,
			&i.Email,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBorrowingCreditAmountsByUserID = `-- name: ListBorrowingCreditAmountsByUserID :many
SELECT payer_id AS user_id, SUM(amount)::bigint AS amount
FROM payments
WHERE debtor_id = $1
  AND payer_id != debtor_id
GROUP BY payer_id
ORDER BY payer_id
`

type ListBorrowingCreditAmountsByUserIDRow struct {
	UserID string
	Amount int64
}

func (q *Queries) ListBorrowingCreditAmountsByUserID(ctx context.Context, debtorID string) ([]ListBorrowingCreditAmountsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, listBorrowingCreditAmountsByUserID, debtorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBorrowingCreditAmountsByUserIDRow
	for rows.Next() {
		var i ListBorrowingCreditAmountsByUserIDRow
		if err := rows.Scan(&i.UserID, &i.Amount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLendingCreditAmountsByUserID = `-- name: ListLendingCreditAmountsByUserID :many
SELECT debtor_id AS user_id, SUM(amount)::bigint AS amount
FROM payments
WHERE payer_id = $1
  AND payer_id != debtor_id
GROUP BY debtor_id
ORDER BY debtor_id
`

type ListLendingCreditAmountsByUserIDRow struct {
	UserID string
	Amount int64
}

func (q *Queries) ListLendingCreditAmountsByUserID(ctx context.Context, payerID string) ([]ListLendingCreditAmountsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, listLendingCreditAmountsByUserID, payerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLendingCreditAmountsByUserIDRow
	for rows.Next() {
		var i ListLendingCreditAmountsByUserIDRow
		if err := rows.Scan(&i.UserID, &i.Amount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvent = `-- name: UpdateEvent :exec
UPDATE events
SET name = $2,
    amount = $3,
    event_date = $4,
    updated_at = $5
WHERE id = $1
`

type UpdateEventParams struct {
	ID        string
	Name      string
	Amount    int32
	EventDate time.Time
	UpdatedAt time.Time
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) error {
	_, err := q.db.Exec(ctx, updateEvent,
		arg.ID,
		arg.Name,
		arg.Amount,
		arg.EventDate,
		arg.UpdatedAt,
	)
	return err
}

const updateGroup = `-- name: UpdateGroup :exec
UPDATE groups
SET name = $2,
    updated_at = $3
WHERE id = $1
`

type UpdateGroupParams struct {
	ID        string
	Name      string
	UpdatedAt time.Time
}

func (q *Queries) UpdateGroup(ctx context.Context, arg UpdateGroupParams) error {
	_, err := q.db.Exec(ctx, updateGroup, arg.ID, arg.Name, arg.UpdatedAt)
	return err
}

const updatePaymentAmount = `-- name: UpdatePaymentAmount :exec
UPDATE payments
SET amount = $2,
    updated_at = current_timestamp
WHERE id = $1
`

type UpdatePaymentAmountParams struct {
	ID     string
	Amount int32
}

func (q *Queries) UpdatePaymentAmount(ctx context.Context, arg UpdatePaymentAmountParams) error {
	_, err := q.db.Exec(ctx, updatePaymentAmount, arg.ID, arg.Amount)
	return err
}

const updateRepayment = `-- name: UpdateRepayment :exec
UPDATE payments
SET amount = $2, updated_at = $3
WHERE id = $1
`

type UpdateRepaymentParams struct {
	ID        string
	Amount    int32
	UpdatedAt time.Time
}

func (q *Queries) UpdateRepayment(ctx context.Context, arg UpdateRepaymentParams) error {
	_, err := q.db.Exec(ctx, updateRepayment, arg.ID, arg.Amount, arg.UpdatedAt)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET name = $2, avatar = $3, updated_at = current_timestamp
WHERE id = $1
`

type UpdateUserParams struct {
	ID     string
	Name   string
	Avatar string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser, arg.ID, arg.Name, arg.Avatar)
	return err
}
